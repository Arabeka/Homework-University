% pi.pro
% by Ray Reeves
%
% pi.pro calculates the digits of pi to the specified number.
% To use it:
%
% > consult(pi).
% ?- main.
% digits (0. to end)? 48.
% pi = 3.1415926535897932384626433832795028841971693993751
% digits (0. to end)? 256.
% pi = 3.14159265358979323846264338327950288419716939937510582
% 097494459230781640628620899862803482534211706798214808651328
% 230647093844609550582231725359408128481117450284102701938521
% 105559644622948954930381964428810975665933446128475648233786
% 783165272019091456485
% digits (0. to end)? 0.
% pi = 3.1
% yes
%
% The program illustrates the use of Amzi! Prolog infinite
% precision real numbers, and the use of various precision
% flags for controlling the degree of accuracy of a
% result generated by an infinite series.
%
% Amzi! reals are represented internally as a list of gigadigits,
% or gigits, which are 0-999999999.  That is, reals are internally
% represented as numbers to the base one billion, 10**9.
%
% Precision of arithmetic is controlled by the flags:
%
% epsilon - the degree of accuracy in series expansions, a negative
%           exponent, rounded internally to a factor of 9,
%           that defines a degree of accuracy that is 'close enough'
%           for sqrt and power functions.
% delta   - the buffer degree of accuracy in divisions, rounded
%           internally to a factor of 9, that is provided for expanding
%           division results.
%
% The display precision of decimal numbers is controlled by the
% flag decimal_places, which is specified in decimal digits.
%
% See documentation for more details.
%
% Pi is calculated as 4 times the arctangent of 1.  The
% arctangent is calculated using Euler's series:
%
%  arctan x = y/x(1 + (2/3)y + (2*4/3*5)y**2 + (2*4*6/3*5*7)y**3 + ...
%  where:	
%     y = (x**2)/(1 + x**2)
%

% First specify that the program will use infinite precision
% real numbers, rather than floats, for decimals.

:- set_prolog_flag(decimals, real).

main :-
	repeat,
	write(`digits (0. to end)? `),
	read(N),
	once pin(N, PI),
	write(pi = PI), nl,
	N == 0.

pin(N, Pi):-
	DecPlaces is N,
	Delta is N + 1,
	Epsilon is -(N+9),  % provide an extra gigit of accuracy
	set_prolog_flag(decimal_places, DecPlaces),	
	set_prolog_flag(delta, Delta),	
	set_prolog_flag(epsilon, Epsilon),

	% calculate pi to precision required
	arctan(1, Arctan),
	Pi is 4*Arctan.

arctan(X, Atan):-
	% We need to check epsilon as well
	current_prolog_flag(epsilon, Exponent),
	Epsilon is 10**(Exponent),
	XX is X*X,
	Y is XX/(1 + XX), 
	series(2/3, 1, 1, Epsilon, Y, Redux),
	Atan is Redux*(Y/X).

series(NIn/DIn, TermIn, SumIn, Epsilon, Y, Redux):-
	T is TermIn*(NIn/DIn)*Y,
	truncate(T, Term), 
	Sum is SumIn + Term,
	(
		(Sum - SumIn) < Epsilon -> 
		Redux = Sum
		;
		N is NIn + 2,
		D is DIn + 2,
		series( N/D, Term, Sum, Epsilon, Y, Redux)
	).

